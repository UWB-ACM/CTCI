<!-- Don't remove -->
<a name="top"/>

# Backtracking

***Problem and solution for Backtracking session on January 29, 2021.***

<a name="p1"/>

## 1. Permutations

Source: [LeetCode](https://leetcode.com/problems/permutations/)

#### Scenario
Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.

#### Example 1:
**Input:** `nums = [1,2,3]`
**Output:** `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`

#### Example 2:
**Input:** `nums = [0,1]`
**Output:** `[[0,1],[1,0]]`

#### Example 3:
**Input:** `nums = [1]`
**Output:** `[[1]]`

**Constraints:**
1 <= nums.length <= 6
-10 <= nums[i] <= 10
All the integers of nums are unique.

#### Java Function Signature:
`public List<List<Integer>> permute(int[] nums)`

<!-- Don't remove -->
Go to [Solution](#s1)   [Top](#top)

<!-- Don't remove -->
<a name="s1"/>

### 1. Permutations

Source: [LeetCode](https://leetcode.com/problems/permutations/)

#### Solution

This solution creates a list of ints from the original array, 
and then puts it as an argument into the backtrack
method, which causes it to be added to the the final list 
that's going to be returned. When it is used as an argument 
in the backtrack method, it finds the next list of ints and 
repeats the same steps until all permutated lists are 
found. (Time complexity: O(2^N), space complexity: O(N))

```
class Solution { 
    public List<List<Integer>> permute(int[] nums) {
        //Create final list to be returned
        List<List<Integer>> list = new ArrayList<>();
    
        //Call backtrack function
        backtrack(list, new ArrayList<>(), nums);
    
        //Return final list
        return list;
}

private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums) {
    //Add current list to final list if same length as original array
    if(tempList.size() == nums.length) {
        list.add(new ArrayList<>(tempList));
    } 
    else {
        for(int i = 0; i < nums.length; i++) {
            //If element already exists, skip
            if(tempList.contains(nums[i])) continue;
            tempList.add(nums[i]);
            backtrack(list, tempList, nums);
            tempList.remove(tempList.size() - 1);
        }
    }
} 
}
```
